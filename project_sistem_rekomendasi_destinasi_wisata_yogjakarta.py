# -*- coding: utf-8 -*-
"""Project sistem rekomendasi destinasi wisata yogjakarta.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yZsBc3JteDk1cS6R-EJ-e78ExYc0tnqV

#**Business Understanding**

Sebelum memutuskan daftar perjalanan, seseorang perlu memiliki gambaran tentang tempat-tempat tersebut.

Yogyakarta memiliki lebih dari cukup destinasi wisata, tetapi bagaimana situasi pariwisata setelah covid-19? Pada bulan Oktober 2021, sektor pariwisata di Indonesia mulai bangkit setelah jeda pandemi.

Proyek ini berisi destinasi wisata top-n di Yogyakarta berdasarkan pengguna lokal, penilaian, dan tempat.

##Import Library
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
from zipfile import ZipFile
from pathlib import Path
import seaborn as sns
import matplotlib.pyplot as plt
# %matplotlib inline
sns.set_palette('Set1')
sns.set()
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
import warnings
warnings.filterwarnings('ignore')
import os

"""##Dataset Info

Note:
* tourism_with_id.csv - berisi informasi tentang 5 kota besar di Indonesia, untuk kasus ini, hanya Yogyakarta yang akan digunakan
* user.csv - berisi informasi pengguna untuk membuat fitur rekomendasi
* tourism_rating.csv - berisi informasi pengguna, tujuan wisata, dan penilaian untuk membuat sistem rekomendasi berdasarkan penilaian

#**Data Understanding**

## Load Dataset
"""

from google.colab import drive
drive.mount('/content/drive')

rating = pd.read_csv('/content/drive/MyDrive/CODING CAMP 2025/Project Machine Learning Terapan/Project sistem rekomendasi/dataset_wisata/tourism_rating.csv')
place = pd.read_csv('/content/drive/MyDrive/CODING CAMP 2025/Project Machine Learning Terapan/Project sistem rekomendasi/dataset_wisata/tourism_with_id.csv')
user = pd.read_csv('/content/drive/MyDrive/CODING CAMP 2025/Project Machine Learning Terapan/Project sistem rekomendasi/dataset_wisata/user.csv')

"""##Eksplorasi Fitur Data"""

place.head(2)

place = place.drop(['Unnamed: 11','Unnamed: 12'],axis=1)
place.head(2)

# Tampilkan hanya Yogyakarta
place = place[place['City']=='Yogyakarta']
place.head(2)

place.loc[:, ['Time_Minutes']].mean(axis = 0)

place.info()

rating.head()

rating.info()

# ubah data rating sehingga akan berisi rating tujuan di Yogyakarta

rating = pd.merge(rating, place[['Place_Id']], how='right', on='Place_Id')
rating.head()

rating.shape

user.head()

# ubah data responden menjadi pengunjung tujuan Yogyakarta

user = pd.merge(user, rating[['User_Id']], how='right', on='User_Id').drop_duplicates().sort_values('User_Id')
user.head()

# mencari dataset responden yang memberikan penilaian untuk destinasi di Yogyakarta
user.shape

"""##Explorasi Data"""

# mengubah penamaan menjadi bahasa Inggris
place.Category[place.Category == 'Taman Hiburan'] = 'Amusement Park & Downtown Attractions'
place.Category[place.Category == 'Budaya'] = 'Culture'
place.Category[place.Category == 'Cagar Alam'] = 'National Park'
place.Category[place.Category == 'Taman Hiburan'] = 'Amusement Park'
place.Category[place.Category == 'Bahari'] = 'Marine Tourism'
place.Category[place.Category == 'Pusat Perbelanjaan'] = 'Shopping Center'

# membuat visualisasi kategori jumlah untuk destinasi Yogyakarta
sns.countplot(y='Category', data=place)
plt.title('Perbandingan Kategori Pariwisata di Yogyakarta', pad=20)
plt.show()

# memvisualisasikan distribusi pengunjung
plt.figure(figsize=(5,3))
sns.boxplot(user['Age']);
plt.title('Distribusi Usia Pengunjung', pad=20)
plt.show()

# memvisualisasikan rentang biaya masuk untuk tujuan
plt.figure(figsize=(12,6))
sns.boxplot(place['Price'])
plt.title('Distribusi Tiket Masuk untuk Destinasi Wisata Yogyakarta', pad=20)
plt.show()

# Mengagregasi Harga dan Waktu_Detik untuk kategori tujuan
place.groupby("Category").agg({"Price":["mean", "sum"],
                       "Time_Minutes":["mean", "sum"]})

# memfilter asal kota pengunjung
askot = user['Location'].apply(lambda x : x.split(',')[0])

# memvisualisasikan asal kota pengunjung
plt.figure(figsize=(8,6))
sns.countplot(y=askot)
plt.title('Sum of Visitors Origin')
plt.show()

"""#**Data Preparation**

##Membuat Salinan untuk Penilaian Data
"""

# membaca dataset untuk encoding
df = rating.copy()
df.head()

"""##Encoding"""

def dict_encoder(col, data=df):

  # mengubah kolom dataframe menjadi daftar dengan nilai unik
  unique_val = data[col].unique().tolist()

  # mengenumerasi nilai kolom dari dataframe
  val_to_val_encoded = {x: i for i, x in enumerate(unique_val)}

  # proses encoding dari angka ke nilai kolom dataframe
  val_encoded_to_val = {i: x for i, x in enumerate(unique_val)}
  return val_to_val_encoded, val_encoded_to_val

# Encoding User_Id
user_to_user_encoded, user_encoded_to_user = dict_encoder('User_Id')

# Mapping User_Id ke dalam dataframe
df['user'] = df['User_Id'].map(user_to_user_encoded)

# Encoding Place_Id
place_to_place_encoded, place_encoded_to_place = dict_encoder('Place_Id')

# Mapping Place_Id ke dalam dataframe place
df['place'] = df['Place_Id'].map(place_to_place_encoded)

"""##Melihat Gambaran Umum Modelling Data"""

# mendapatkan panjang user & user
num_users, num_place = len(user_to_user_encoded), len(place_to_place_encoded)

# mengubah rating menjadi float
df['Place_Ratings'] = df['Place_Ratings'].values.astype(np.float32)

# mendapatkan rating minimum dan maksimum
min_rating, max_rating = min(df['Place_Ratings']), max(df['Place_Ratings'])

print(f'Number of User: {num_users}, Number of Place: {num_place}, Min Rating: {min_rating}, Max Rating: {max_rating}')

# mengacak dataset
df = df.sample(frac=1, random_state=42)
df.head(2)

"""#**Modelling**

##Mengalokasikan data train dan test
"""

# membuat variabel x untuk mencocokkan user menjadi satu nilai
x = df[['user', 'place']].values

# membuat variabel y untuk memulai rating
y = df['Place_Ratings'].apply(lambda x: (x - min_rating) / (max_rating - min_rating)).values

# mengalokasikan data training 80% & data validation 20%
train_indices = int(0.8 * df.shape[0])
x_train, x_val, y_train, y_val = (
    x[:train_indices],
    x[train_indices:],
    y[:train_indices],
    y[train_indices:]
)

"""##Model Preparation"""

class RecommenderNet(tf.keras.Model):

  # Function initialization
  def __init__(self, num_users, num_places, embedding_size, **kwargs):
    super(RecommenderNet, self).__init__(**kwargs)
    self.num_users = num_users
    self.num_places = num_places
    self.embedding_size = embedding_size
    self.user_embedding = layers.Embedding( # layer embedding user
        num_users,
        embedding_size,
        embeddings_initializer = 'he_normal',
        embeddings_regularizer = keras.regularizers.l2(1e-6)
    )
    self.user_bias = layers.Embedding(num_users, 1) # layer embedding user bias
    self.places_embedding = layers.Embedding( # layer embeddings places
        num_places,
        embedding_size,
        embeddings_initializer = 'he_normal',
        embeddings_regularizer = keras.regularizers.l2(1e-6)
    )
    self.places_bias = layers.Embedding(num_places, 1) # layer embedding places bias

  def call(self, inputs):
    user_vector = self.user_embedding(inputs[:,0]) # layer embedding 1
    user_bias = self.user_bias(inputs[:, 0]) # layer embedding 2
    places_vector = self.places_embedding(inputs[:, 1]) # layer embedding 3
    places_bias = self.places_bias(inputs[:, 1]) # layer embedding 4

    dot_user_places = tf.tensordot(user_vector, places_vector, 2)

    x = dot_user_places + user_bias + places_bias

    return tf.nn.sigmoid(x) # activation sigmoid

model = RecommenderNet(num_users, num_place, 50) # model initialization

# model compile
model.compile(
    loss = tf.keras.losses.BinaryCrossentropy(),
    optimizer = keras.optimizers.Adam(learning_rate=0.0004),
    metrics=[tf.keras.metrics.RootMeanSquaredError()]
)

class myCallback(tf.keras.callbacks.Callback):
  def on_epoch_end(self, epoch, logs={}):
    if(logs.get('val_root_mean_squared_error')<0.25):
      print('Fulfilled expected validation matrix')
      self.model.stop_training = True

# training

history = model.fit(
    x = x_train,
    y = y_train,
    epochs = 100,
    validation_data = (x_val, y_val),
    callbacks = [myCallback()]
)

"""#Evaluation Model"""

# Ambil data dari objek history
history_df = pd.DataFrame(history.history)

# Tambahkan kolom epoch
history_df['Epoch'] = history_df.index + 1

# Ubah nama kolom agar sesuai format yang diinginkan
formatted_df = history_df.rename(columns={
    'root_mean_squared_error': 'Train RMSE',
    'val_root_mean_squared_error': 'Validation RMSE',
    'loss': 'Train Loss',
    'val_loss': 'Validation Loss'
})

# Urutkan kolom sesuai permintaan
formatted_df = formatted_df[[
    'Epoch',
    'Train RMSE',
    'Validation RMSE',
    'Train Loss',
    'Validation Loss'
]]

# Tampilkan tabel
print("Hasil Evaluasi Model:\n")
print(formatted_df.to_string(index=False))

# menunjukkan plot loss and validation
plt.plot(history.history['root_mean_squared_error'])
plt.plot(history.history['val_root_mean_squared_error'])
plt.title('model_metrics')
plt.ylabel('root_mean_squared_error')
plt.xlabel('epoch')
plt.ylim(ymin=0, ymax=0.4)
plt.legend(['train', 'test'], loc='center left')
plt.show()

"""#Prediksi 7 Destinasi yang direkomendasikan

##Persiapan DataFrame untuk Menampilkan Rekomendasi
"""

place_df = place[['Place_Id','Place_Name','Category','Rating','Price']]
place_df.columns = ['id','place_name','category','rating','price']
df = rating.copy()

"""##Contoh user untuk Menampilkan Rekomendasi"""

# user sampling
user_id = df.User_Id.sample(1).iloc[0]
place_visited_by_user = df[df.User_Id == user_id]

# data location yang belum dikunjungi
place_not_visited = place_df[~place_df['id'].isin(place_visited_by_user.Place_Id.values)]['id']
place_not_visited = list(
    set(place_not_visited)
    .intersection(set(place_to_place_encoded.keys()))
)

place_not_visited = [[place_to_place_encoded.get(x)] for x in place_not_visited]
user_encoder = user_to_user_encoded.get(user_id)
user_place_array = np.hstack(
    ([[user_encoder]] * len(place_not_visited), place_not_visited)
)

"""##Menampilkan Rekomendasi untuk user"""

# top 7 Rekomendasi
ratings = model.predict(user_place_array).flatten()
top_ratings_indices = ratings.argsort()[-7:][::-1]
recommended_place_ids = [
    place_encoded_to_place.get(place_not_visited[x][0]) for x in top_ratings_indices
]

print('Daftar rekomendasi untuk: {}'.format('User ' + str(user_id)))
print('===' * 15,'\n')
print('----' * 15)
print('Tempat dengan rating tertinggi dari user')
print('----' * 15)

top_place_user = (
    place_visited_by_user.sort_values(
        by = 'Place_Ratings',
        ascending=False
    )
    .head(5)
    .Place_Id.values
)

place_df_rows = place_df[place_df['id'].isin(top_place_user)]
for row in place_df_rows.itertuples():
    print(row.place_name, ':', row.category)

print('')
print('----' * 15)
print('Top 7 rekomendasi tempat')
print('----' * 15)

recommended_place = place_df[place_df['id'].isin(recommended_place_ids)]
for row, i in zip(recommended_place.itertuples(), range(1,8)):
    print(i,'.', row.place_name, '\n    ', row.category, ',', 'Entrance Fee', row.price, ',', 'Rating', row.rating,'\n')

print('==='*15)